{"version":3,"sources":["webpack:///./node_modules/fg-loadcss/src/cssrelpreload.js","webpack:///(webpack)/buildin/global.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,uC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA,KAAK,IAA8B;AACnC;AACA;AACA,MAAM,EAEJ;AACF,CAAC;;;;;;;;;;;;;AC9GD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C","file":"4.3c36941774fdbc96c8a6.js","sourcesContent":["/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */\n/* This file is meant as a standalone workflow for\n- testing support for link[rel=preload]\n- enabling async CSS loading in browsers that do not support rel=preload\n- applying rel preload css once loaded, whether supported or not.\n*/\n(function( w ){\n\t\"use strict\";\n\t// rel=preload support test\n\tif( !w.loadCSS ){\n\t\tw.loadCSS = function(){};\n\t}\n\t// define on the loadCSS obj\n\tvar rp = loadCSS.relpreload = {};\n\t// rel=preload feature support test\n\t// runs once and returns a function for compat purposes\n\trp.support = (function(){\n\t\tvar ret;\n\t\ttry {\n\t\t\tret = w.document.createElement( \"link\" ).relList.supports( \"preload\" );\n\t\t} catch (e) {\n\t\t\tret = false;\n\t\t}\n\t\treturn function(){\n\t\t\treturn ret;\n\t\t};\n\t})();\n\n\t// if preload isn't supported, get an asynchronous load by using a non-matching media attribute\n\t// then change that media back to its intended value on load\n\trp.bindMediaToggle = function( link ){\n\t\t// remember existing media attr for ultimate state, or default to 'all'\n\t\tvar finalMedia = link.media || \"all\";\n\n\t\tfunction enableStylesheet(){\n\t\t\t// unbind listeners\n\t\t\tif( link.addEventListener ){\n\t\t\t\tlink.removeEventListener( \"load\", enableStylesheet );\n\t\t\t} else if( link.attachEvent ){\n\t\t\t\tlink.detachEvent( \"onload\", enableStylesheet );\n\t\t\t}\n\t\t\tlink.setAttribute( \"onload\", null ); \n\t\t\tlink.media = finalMedia;\n\t\t}\n\n\t\t// bind load handlers to enable media\n\t\tif( link.addEventListener ){\n\t\t\tlink.addEventListener( \"load\", enableStylesheet );\n\t\t} else if( link.attachEvent ){\n\t\t\tlink.attachEvent( \"onload\", enableStylesheet );\n\t\t}\n\n\t\t// Set rel and non-applicable media type to start an async request\n\t\t// note: timeout allows this to happen async to let rendering continue in IE\n\t\tsetTimeout(function(){\n\t\t\tlink.rel = \"stylesheet\";\n\t\t\tlink.media = \"only x\";\n\t\t});\n\t\t// also enable media after 3 seconds,\n\t\t// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link\n\t\tsetTimeout( enableStylesheet, 3000 );\n\t};\n\n\t// loop through link elements in DOM\n\trp.poly = function(){\n\t\t// double check this to prevent external calls from running\n\t\tif( rp.support() ){\n\t\t\treturn;\n\t\t}\n\t\tvar links = w.document.getElementsByTagName( \"link\" );\n\t\tfor( var i = 0; i < links.length; i++ ){\n\t\t\tvar link = links[ i ];\n\t\t\t// qualify links to those with rel=preload and as=style attrs\n\t\t\tif( link.rel === \"preload\" && link.getAttribute( \"as\" ) === \"style\" && !link.getAttribute( \"data-loadcss\" ) ){\n\t\t\t\t// prevent rerunning on link\n\t\t\t\tlink.setAttribute( \"data-loadcss\", true );\n\t\t\t\t// bind listeners to toggle media back\n\t\t\t\trp.bindMediaToggle( link );\n\t\t\t}\n\t\t}\n\t};\n\n\t// if unsupported, run the polyfill\n\tif( !rp.support() ){\n\t\t// run once at least\n\t\trp.poly();\n\n\t\t// rerun poly on an interval until onload\n\t\tvar run = w.setInterval( rp.poly, 500 );\n\t\tif( w.addEventListener ){\n\t\t\tw.addEventListener( \"load\", function(){\n\t\t\t\trp.poly();\n\t\t\t\tw.clearInterval( run );\n\t\t\t} );\n\t\t} else if( w.attachEvent ){\n\t\t\tw.attachEvent( \"onload\", function(){\n\t\t\t\trp.poly();\n\t\t\t\tw.clearInterval( run );\n\t\t\t} );\n\t\t}\n\t}\n\n\n\t// commonjs\n\tif( typeof exports !== \"undefined\" ){\n\t\texports.loadCSS = loadCSS;\n\t}\n\telse {\n\t\tw.loadCSS = loadCSS;\n\t}\n}( typeof global !== \"undefined\" ? global : this ) );\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}